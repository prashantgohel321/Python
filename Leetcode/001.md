# LeetCode Task 01: Two Sum (Easy)

Hey there! This is my personal guide to solving the classic "Two Sum" problem. If you're just starting out, you're in the right place! I'm going to walk you through my thought process, explain the key Python concepts we'll use, and break down the code so it all makes perfect sense.

## Table of Contents
- [The Problem in Simple Terms](#the-problem-in-simple-terms)
- [My Core Concepts for This Task](#my-core-concepts-for-this-task)
- [My Solution Explained, Step-by-Step](#my-solution-explained-step-by-step)
- [Let's Do a Dry Run Together](#lets-do-a-dry-run-together)
- [How Efficient is This Solution? (Complexity)](#how-efficient-is-this-solution-complexity)
- [My Full Python Code with Notes](#my-full-python-code-with-notes)

---

### The Problem in Simple Terms
<a name="the-problem-in-simple-terms"></a>
The challenge is pretty straightforward: we're given a list of numbers (like `[2, 7, 11, 15]`) and a target number (like `9`). Our job is to find two numbers in that list that add up exactly to the target. When we find them, we need to return their positions (indices) in the list.

For `nums = [2, 7, 11, 15]` and `target = 9`, the answer is `[0, 1]` because `nums[0]` (which is 2) plus `nums[1]` (which is 7) equals 9.

---

### My Core Concepts for This Task
<a name="my-core-concepts-for-this-task"></a>
To solve this efficiently, I rely on a couple of key ideas.

#### 1. The Power of a Hash Map (or `dict` in Python)
Imagine you have a magic notebook. You can write down a piece of information (like a number from our list) and label it with its location (its index). The magic part is that you can instantly look up any label and find the information you stored.

That's exactly what a hash map, or a Python dictionary (`dict`), does! It stores data in **key-value pairs**. For this problem, my plan is to use it like this:
- **Key:** A number from the `nums` list.
- **Value:** The index where that number is located.

This is amazing because looking up if a key exists in a dictionary is incredibly fast—it takes about the same amount of time no matter how many items are in it!

#### 2. Using `enumerate()` to Loop Smartly
When I loop through a list in Python, I often need two things at once: the item itself and its index. I could use a separate counter variable, but Python gives us a much cleaner way to do this: the `enumerate()` function.

It turns a simple loop like this:
```python
for num in nums:
    # do something with num
```
Into a more powerful loop like this:
```python
for i, num in enumerate(nums):
    # 'i' is the index, and 'num' is the value!
```
This is perfect for our task because we need to keep track of indices.

#### 3. The "Complement" Trick
This is the heart of the logic. For any number `num` in our list, the other number we're looking for (its complement) is simply `target - num`.

If our target is `9` and our current number is `2`, its complement is `9 - 2 = 7`. So, instead of searching for a pair, I can just ask a simpler question at each step: "Have I already seen a `7`?" The hash map is the perfect tool to answer that question instantly.

---

### My Solution Explained, Step-by-Step
<a name="my-solution-explained-step-by-step"></a>
My strategy is to solve this in a single pass through the list, which is very efficient. Here’s how I do it:

1.  **Create an empty dictionary:** I'll start by making an empty dictionary, let's call it `num_map`, to store the numbers I've seen so far and their indices.
2.  **Loop through the list:** Using `enumerate()`, I'll go through each number (`num`) and its index (`i`) in the `nums` list.
3.  **Find the complement:** For each `num`, I'll calculate the `complement` I need: `complement = target - num`.
4.  **Check the dictionary:** Now, the crucial part. I'll check if this `complement` already exists as a key in my `num_map`.
    * **If it exists:** Hooray! I've found the pair. The `complement` is the number I saw earlier, and its index is stored as the value in my dictionary (`num_map[complement]`). The current `num` is the second number. So, I can immediately return `[num_map[complement], i]`.
    * **If it doesn't exist:** No problem. It just means the current `num` isn't the second half of a pair I've seen *yet*. So, I'll add the current `num` and its index `i` to my `num_map`. This way, a future number can find it as *its* complement.
5.  I keep repeating this until I find the pair. Since the problem guarantees a solution exists, I'll always find one.

---

### Let's Do a Dry Run Together
<a name="lets-do-a-dry-run-together"></a>
Walking through an example makes everything clearer. Let's use `nums = [2, 7, 11, 15]` and `target = 9`.

**Initial State:** `num_map = {}`

| Current `i` | Current `num` | `complement` (9 - num) | `num_map` (Before Check) | Is `complement` in `num_map`? | Action | `num_map` (After Action) |
| :---: | :---: | :---: | :--- | :---: | :--- | :--- |
| **0** | `2` | `7` | `{}` | No | Add `2` and its index `0` to the map. | `{2: 0}` |
| **1** | `7` | `2` | `{2: 0}` | **Yes!** The key `2` is in the map. | Found it! Return `[num_map[2], i]` which is `[0, 1]`. | `{2: 0}` |

And that's it! The function stops and returns `[0, 1]`.

---

### How Efficient is This Solution? (Complexity)
<a name="how-efficient-is-this-solution-complexity"></a>
- **Time Complexity: O(n)**
  - This sounds technical, but it just means the time it takes to run my solution grows in a straight line with the size of the input list (`n`). Since I only loop through the list once, it's super fast and efficient.

- **Space Complexity: O(n)**
  - This refers to how much extra memory I need. In the worst case, I might have to store almost every number in my `num_map` before I find the pair. So, the memory needed is proportional to the size of the list.

---

### My Full Python Code with Notes
<a name="my-full-python-code-with-notes"></a>
Here is the final code with comments explaining each part of my process.
```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        # I'll create my "magic notebook" (a dictionary) to store numbers I've seen.
        # The format will be {number: index}.
        num_map = {}

        # I'll loop through the list, getting both the index (i) and the number (num).
        for i, num in enumerate(nums):
            # For each number, I calculate the 'complement' needed to hit the target.
            complement = target - num
            
            # Now, I check my notebook: have I seen this complement before?
            if complement in num_map:
                # If yes, I've found my pair!
                # The index of the complement is num_map[complement],
                # and the index of the current number is i.
                return [num_map[complement], i]
            
            # If the complement isn't in my notebook, it means I haven't seen it yet.
            # So, I'll add the CURRENT number and its index to the notebook.
            # This way, it's available for future numbers to find.
            num_map[num] = i
```