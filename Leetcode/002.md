# LeetCode Task 02: Add Two Numbers (Medium)

This document provides a detailed, beginner-friendly explanation for solving the LeetCode problem "Add Two Numbers". We will cover the core data structure (Linked Lists) and walk through the logic of the solution step-by-step.

## Table of Contents
- [Problem Description](#problem-description)
- [Core Concepts for Beginners](#core-concepts-for-beginners)
- [Solution Explained](#solution-explained)
- [Dry Run / Walkthrough](#dry-run--walkthrough)
- [Complexity Analysis](#complexity-analysis)
- [Full Python Code](#full-python-code)

---

### Problem Description
<a name="problem-description"></a>
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:**
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```
The lists are in reverse order. `[2,4,3]` represents the number 342, and `[5,6,4]` represents 465.

---

### Core Concepts for Beginners
<a name="core-concepts-for-beginners"></a>

#### 1. What is a Linked List?
In Python, a standard list (like `[2, 4, 3]`) is stored as one continuous block of memory. A **Linked List** is different. It's a sequence of connected elements called **nodes**.

- Each **node** contains two things:
  1. A `value` (in this problem, a single digit).
  2. A `next` pointer, which points to the next node in the sequence.
- The last node in the list has its `next` pointer set to `None`, indicating the end.

The problem provides this class definition for a node:
```python
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```
So, `l1 = [2,4,3]` is actually represented like this:
`Node(2) -> Node(4) -> Node(3) -> None`

#### 2. The "Dummy Head" Node Technique
When we build our new result linked list, we need a starting point. A common and clever trick is to create a `dummy_head` node.
- It's a placeholder node that sits before the *actual* first node of our result.
- We attach the first *real* result node to `dummy_head.next`.
- This simplifies the code because we don't need a special `if` condition to handle adding the very first node to an empty list.
- At the end, we simply return `dummy_head.next`, which is the true start of our result list.

#### 3. Modulo (`%`) and Floor Division (`//`)
This problem mimics grade-school addition. When you add `8 + 7 = 15`, you write down `5` and `carry` the `1`.
- **Modulo (`%`)** gives us the remainder. `15 % 10` is `5`. This is the digit we "write down".
- **Floor Division (`//`)** gives us the integer quotient. `15 // 10` is `1`. This is the digit we "carry over".

---

### Solution Explained
<a name="solution-explained"></a>
The core idea is to simulate manual addition from right to left, which is easy because the linked lists are already in reverse order. We iterate through both lists simultaneously.

1.  **Initialization:**
    -   Create a `dummy_head = ListNode(0)` to serve as the starting point for our result list.
    -   Create a `current` pointer, initially set to `dummy_head`. We will use this to build the new list by adding nodes to `current.next`.
    -   Initialize a `carry` variable to `0`. This will store the carry-over value during addition.

2.  **Iteration:**
    -   We'll use a `while` loop that continues as long as there are digits in `l1`, `l2`, or if there's a remaining `carry`. The condition `while l1 or l2 or carry:` covers all cases.
    -   Inside the loop, for each position:
        a.  Get the values from the current nodes of `l1` and `l2`. If one list is shorter and has ended (i.e., the node is `None`), we treat its value as `0`.
        b.  Calculate `total_sum = val1 + val2 + carry`.
        c.  Determine the new `digit` for our result list using the modulo operator: `digit = total_sum % 10`.
        d.  Update the `carry` for the *next* iteration using floor division: `carry = total_sum // 10`.
        e.  Create a new `ListNode` with the `digit` and attach it to our result list: `current.next = ListNode(digit)`.
        f.  Move the `current` pointer forward: `current = current.next`.
        g.  Move the `l1` and `l2` pointers forward to their next nodes, if they exist.

3.  **Return Value:**
    -   After the loop finishes, our `dummy_head` node points to the start of the complete result list. We return `dummy_head.next`.

---

### Dry Run / Walkthrough
<a name="dry-run--walkthrough"></a>
Let's trace the solution with `l1 = [2,4,3]` and `l2 = [5,6,4]`.

**Initial State:** `dummy_head = Node(0)`, `current = dummy_head`, `carry = 0`, `Result = []`

| Iteration | `l1.val` | `l2.val` | `carry` (Start) | `total_sum` | `digit` (sum % 10) | `carry` (End) | `Result` List (so far) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :--- |
| **1** | 2 | 5 | 0 | 2+5+0 = 7 | 7 | 0 | `[7]` |
| **2** | 4 | 6 | 0 | 4+6+0 = 10 | 0 | 1 | `[7, 0]` |
| **3** | 3 | 4 | 1 | 3+4+1 = 8 | 8 | 0 | `[7, 0, 8]` |

After iteration 3, `l1` is `None`, `l2` is `None`, and `carry` is `0`. The loop condition is false, so it terminates. The final result is `[7, 0, 8]`.

---

### Complexity Analysis
<a name="complexity-analysis"></a>
Let `m` be the number of nodes in `l1` and `n` be the number of nodes in `l2`.

- **Time Complexity: O(max(m, n))**
  - We iterate through the linked lists once. The loop runs for a number of times equal to the length of the longer list.

- **Space Complexity: O(max(m, n))**
  - The space required is for the new linked list we create to store the result. In the worst case, the length of the new list is `max(m, n) + 1` (if there's a final carry).

---

### Full Python Code
<a name="full-python-code"></a>
```python
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        # 1. Initialization
        # Create a dummy node to simplify adding the first node.
        dummy_head = ListNode(0) 
        # 'current' will be our pointer to build the new list.
        current = dummy_head
        # 'carry' stores the value to carry over to the next digit's calculation.
        carry = 0

        # 2. Iteration
        # Loop until we have processed all digits from both lists AND handled any final carry.
        while l1 is not None or l2 is not None or carry != 0:
            
            # Get the value from the current l1 node. If l1 is finished, use 0.
            val1 = l1.val if l1 is not None else 0
            # Get the value from the current l2 node. If l2 is finished, use 0.
            val2 = l2.val if l2 is not None else 0

            # Calculate the total sum for the current digit place.
            total_sum = val1 + val2 + carry
            
            # The new digit for our result is the remainder after dividing by 10.
            digit = total_sum % 10
            # The new carry is the integer result of dividing by 10.
            carry = total_sum // 10

            # Create a new node with the calculated digit and link it to our result list.
            current.next = ListNode(digit)
            
            # Move our builder pointer forward.
            current = current.next

            # Advance l1 and l2 to their next nodes for the next iteration.
            l1 = l1.next if l1 is not None else None
            l2 = l2.next if l2 is not None else None
            
        # 3. Return Value
        # The result starts right after our dummy node.
        return dummy_head.next
```